<!DOCTYPE html>
<html>
<head>
  <title>Symfony Front-end Workflow: Assetic, Bower & Grunt</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <!--RSS-->
  <link rel="alternate" type="application/rss+xml" title="Bruno Garcia" href="http://blog.garciaechegaray.com/feed.xml">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/css/app.css?v=4">

  <!--Favicon-->
  <link rel="shortcut icon" href="/favicon.ico" />

  <!--Modernizr-->
  <script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.7.0/modernizr.min.js"></script>

  <!--Google Analytics-->
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-18260985-4']);
    _gaq.push(['_setDomainName', '.garciaechegaray.com']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>

</head>
<body>

  <!--Nav-->
  <div class="fixed">
    <nav class="top-bar" data-topbar>

      <ul class="title-area">
        <li class="name">
          <h1><a href="http://blog.garciaechegaray.com/">Bruno Garcia Echegaray</a></h1>
        </li>
        <li class="toggle-topbar menu-icon">
          <a href="">
            <span>Menu</span>
          </a>
        </li>
      </ul>

      <section class="top-bar-section">
        <ul class="right">
          <li class="divider"></li>
          <li><a href="http://bruno.garciaechegaray.com">Sobre mi</a></li>
          <li class="divider"></li>
          <li class="active"><a href="http://blog.garciaechegaray.com/">Blog</a></li>
          <li class="divider"></li>
          <li><a href="http://www.tuttifrescuni.com" title="Tutti Frescuni: ¿qué frutas y verduras se encuentran de temporada?" target="_blank">Pet Project</a></li>
          <li class="divider"></li>
          <li><a href="https://github.com/brunogarcia/Front-end-Wiki/wiki" title="Front-end Development Resources" target="_blank">Wiki</a></li>
        </ul>
      </section>

    </nav>
  </div>

  <!--Main-->
  <div class="main">
    <div class="row post-main">
	<div class="small-12 columns">
		<h1>Symfony Front-end Workflow: Assetic, Bower & Grunt</h1>
		<p class="meta">05 Sep 2015</p>

		<div class="post">
		<hr>

<p><big>Despúes de desarrollar un par de proyectos con <a href="http://www.symfony.com/">Symfony</a> he encontrado un flujo de trabajo que funciona bastante bien para trabajar con diferentes librerías front-end en dicho framework PHP</big></p>

<hr>

<p>La idea consiste en utilizar <a href="http://bower.io">Bower</a> para gestionar las dependecias front-end del proyecto. <a href="http://gruntjs.com">Grunt</a> para seleccionar y copiar dichas dependencias a nuestro bundle principal. Y finalmente dejamos que <a href="http://symfony.com/doc/current/cookbook/assetic/index.html">Assetic</a> realice el resto de tareas: aplicar los filtros (sass, rewrite, uglify, etc.) y gestionar el flujo dentro de Symfony.</p>

<p>Implementar todo esto por primera vez requiere una importante carga de configuración, sobre todo si eres completamente nuevo en el mundo Symfony (como era mi caso hasta hace 6 meses), pero una vez le pillas el truco todo va como la seda. </p>

<p>Lo mejor de usar conjuntamente Bower y Grunt, es que toda esta configuración la podemos copiar a otro proyecto y en 5 minutos ya tendremos todos los assets bajados y copiados a sus rutas correspondientes.</p>

<hr>

<h2>Bower</h2>

<p><a href="http://bower.io">Bower</a> es una herramienta <em>open source</em> liberada por Twitter que sirve para gestionar
todas las dependencias de tu proyecto front-end. La idea es similar a <a href="https://getcomposer.org/">Composer</a> en PHP o <a href="http://bundler.io/">Bundler</a> para Ruby.</p>

<p>El funcionamiento de Bower es bastante simple. Primero creas la configuración necesaria en un archivo <em>bower.json</em>. Esto lo puedo hacer a mano o  lanzando el comando <em>bower init</em> en tu consola. El atributo mas importante es <em>dependencies</em>, el cual será un objeto (key: value) con el nombre y la versión de la dependencia.</p>

<p>Para añadir una nueva librería lo primero que debes hacer es buscarla en <a href="http://bower.io/search/">bower.io</a>. Esto también lo puedes hacer por consola lanzando el comando <em>$ bower search NOMBRE</em>DE<em>LA</em>LIBRERIA_.</p>

<p>Si la librería se encuentra registrada como package en Bower entonces la podrás añadir directamente por consola con el flag <em>--save</em></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ bower install --save jquery
</code></pre></div>
<p>Esto modificará automáticamente el fichero <em>bower.json</em> añadiendo la librería con su respectiva versión. Por ejemplo la versión ~2.1.1. El primer simbolo (~) significa que las siguientes veces que solicites a Bower actualizar las dependecias, comenzará siempre con la versión 2.1.1 hasta un máximo de 2.2.0. Puedes encontrar más información sobre este tema en <a href="http://stackoverflow.com/a/20412378">Bower Version Syntax</a>.</p>

<p>Si la librería que necesitas <em>no</em> se encuentra registrada como package en Bower, entonces puedes modificar el <em>bower.json</em> a mano, añadiendo la url al repositorio (público o privado) especificando la versión que deseas utilizar.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&quot;bootstrap-datepicker&quot;: &quot;https://github.com/eternicode/bootstrap-datepicker.git#~1.4.0&quot;
</code></pre></div>
<p>Una vez finalizado este proceso basta con lanzar una línea en tu terminal para tener todas las dependencias disponibles en local. Da igual si son 5 o 50, Bower las bajará todas por ti en pis pas.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ bower install
</code></pre></div>
<p>Los ficheros se guardarán en una carpeta llamada <em>bower components</em>. Dependiendo del autor de la librería encontrarás muchas carperas y ficheros que no serán necesarios para tu proyecto (por ejemplo: test, build, changelogs, licencias, readme, etc.). Pero no hay problema, esto lo resolveremos con un plugin para Grunt llamado <a href="https://www.npmjs.com/package/grunt-bowercopy">bower copy</a>.</p>

<p>Un último punto importante: la carpeta <em>bower components</em>  deberás añadirla a tu fichero <em>.gitignore</em>. Ya que no hace falta subir todas las dependecias al repositorio, siempre que tengas a mano el fichero <em>bower.json</em> puedes realizar la misma tarea todas las veces que quieras. </p>

<script src="https://gist.github.com/brunogarcia/79e9d6880b3d5ab3d7f9.js"></script>

<p>Estos datos los he sacado de <a href="https://www.gitignore.io/">gitignore.io</a>, una herramienta muy útil para saber que carpetas debes ignorar según que tecnología utilizas.</p>

<p>Así es como quedaría un archivo <em>bower.json</em> completamente configurado:</p>

<script src="https://gist.github.com/brunogarcia/062562fde7a65df01fb8.js"></script>

<hr>

<h2>Grunt</h2>

<p><a href="http://gruntjs.com">Grunt</a> creado y mantenido por la gente de <a href="http://bocoup.com/">Bocoup</a>, es una herramienta para automatizar tareas en tu entorno de desarrollo.</p>

<p>Para configurar Grunt son necesarios dos ficheros: <em>package.json</em> y <em>Gruntfile.js</em>. </p>

<p>En <em>package.json</em> deberás listar todas las dependencias necesarias para correr las tareas. En nuestro caso solo necesitamos <a href="https://www.npmjs.com/package/grunt-bowercopy">bower copy</a>, ya que el resto de tareas que normalmente realizariamos con Grunt, en el entorno de Symfony será Assetic quien se encargará de ellas.</p>

<p>Para instalar las dependencias de Grunt deberás escribir en tu consola:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ npm install
</code></pre></div>
<script src="https://gist.github.com/brunogarcia/9f5c2a46f981fe037886.js"></script>

<p>En <em>Gruntfile.js</em> creas la configuración de cada tarea o grupo de tareas. En nuestro caso solo tendremos una única tarea llamada &#39;default&#39;.</p>

<p>Utilizo <a href="https://www.npmjs.com/package/grunt-bowercopy">bower copy</a> para copiar únicamente los ficheros que necesita mi proyecto. 
En este caso, todos se copiaran a <em>/src/AppBundle/Resources/public/</em>. Como podéis ver he dividido los assets en varios grupos: CSS, JS, sass, fonts e imágenes. Dependiendo del grupo al cual pertenezcan, cada asset se copiará a una carpeta distinta. Incluso si os fijaís bien, podemos cambiar el nombre al fichero antes de llevarlo a su destino final.</p>

<p>Para lanzar esta tarea simplemente escribes en tu consola:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ grunt
</code></pre></div>
<p>Si existieran mas tareas, deberíamos especificar el nombre, pero en este caso no es necesario.</p>

<p>Así es como quedaría un archivo <em>Gruntfile.js</em> completamente configurado:</p>

<script src="https://gist.github.com/brunogarcia/000951d92e40ad219c95.js"></script>

<hr>

<h2>Assetic</h2>

<p>Un asset es cualquier componente de nuestro front-end. Por ejemplo un fichero css, js, una imagen o una webfont.</p>

<p><a href="https://github.com/kriswallsmith/assetic">Assetic</a> es el gestor de assets que utiliza Symfony. Assetic está basado en <a href="http://webassets.readthedocs.org/en/latest">webassets</a>, una librería del mundo Python.</p>

<p>Assetic trabaja conjuntamente con el <a href="http://symfony.com/doc/current/components/asset/introduction.html">componente Asset</a> para gestionar todo el flujo de nuestros assets dentro de los entornos de desarrollo y producción de Symfony. Gracias a Assetic podremos aplicar filtros a nuestros assets antes de dejarlos disponibles para el usuario final. Por ejemplo compilar un fichero <em>sass</em> o minimizar y combinar ficheros <em>js</em>.</p>

<p>La configuración de Assetic la haremos siempre en un fichero <a href="http://twig.sensiolabs.org/">twig</a>. </p>

<h3>CSS</h3>

<p>Comencemos con los hojas de estilo de nuestra aplicación. Trabajaremos con un fichero llamado <em>css.html.twig</em> que se encuentra alojado en /app/Resources/views/includes/_</p>

<script src="https://gist.github.com/brunogarcia/612319c831fdd302d599.js"></script>

<p>Como veréis primero aplicamos el filtro <em>sass</em> a nuestro fichero <em>main.scss</em>. Incluso podemos decidir el nombre que tendrá el CSS final, en este caso <em>main.css</em>. Para hacer uso de este filtro es necesario tener instalado <a href="https://www.ruby-lang.org">Ruby</a> y <a href="http://sass-lang.com/">Sass</a> en nuestro entorno. Mi recomendación es instalar siempre Ruby vía <a href="https://rvm.io/">RVM</a> para evitar problemas con las versiones de las gemas.</p>

<p>A continuación aplicamos a un grupo de ficheros CSS (plugins) un par de filtros. El filtro <em>cssrewrite</em> se encarga de sobreescribir las rutas relativas que se encuentren en nuestros estilos. El filtro <em>uglyfycss</em> minifica y concatena nuestros ficheros CSS. Este último filtro necesita <a href="https://nodejs.org">Node</a> y el package <a href="https://github.com/fmarcia/UglifyCSS">UglifyCSS</a> para funcionar.</p>

<p>Si añadimos a cualquier filtro el signo de interrogación <em>?</em> significa que solo debe ejecutar dicha tarea en el entorno de producción. La razón es que no nos interesa trabajar con archivos minificados en el entorno de desarrollo, básicamente porque sería un infierno debugear.</p>

<p>El lector avispado se preguntará por qué no he aplicado el filtro <em>uglifycss</em> a los ficheros <em>sass</em>. La respuesta es sencilla: no hace falta. Sass ya se encarga de minificar y concatenar los ficheros que compila. Solo es necesario especificar este comportamiento en la configuración del entorno de producción de Symfony. </p>

<script src="https://gist.github.com/brunogarcia/1e40e9123c4892b0e281.js"></script>

<h3>Javascript</h3>

<p>Ahora es el turno de los ficheros Javascript. Trabajaremos con un fichero llamado <em>js.html.twig</em> que se encuentra alojado en /app/Resources/views/includes/_</p>

<script src="https://gist.github.com/brunogarcia/416503dd5e2599d43499.js"></script>

<p>En este caso aplicamos un único filtro llamado <em>uglyfyjs</em>, cuya tarea es minificar y concatenar nuestros ficheros js. Este filtro necesita <a href="https://nodejs.org">Node</a> y el package <a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a> para funcionar. Aqui también aplicamos la opción de realizar esta tarea únicamente en el entorno de producción.</p>

<h3>Entornos de Symfony</h3>

<p>Como he mencionado anteriormente, Symfony tiene dos entornos de ejecución diferenciados: desarrollo y producción. 
Dichos entornos de ejecución afectan directamente a la forma de trabajar con nuestros assets. Necesitaremos conocer algunos comandos extras. </p>

<p>El primero es <em>assets install web</em> que buscará dentro de todos nuestros bundles la ruta <em>/Resources/public/</em>. Si encuentra algún fichero los copiará a la ruta pública <em>/web/bunles/[nombre</em>del_bundle].</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ php app/console assets:install web
</code></pre></div>
<p>El segundo es <em>assetic dump</em>. Este comando aplicará los filtros a los assets correspondientes y a continuación los copiará a la ruta <em>/web/</em>. Dependiendo del entorno en el cual quieras realizar el dump, deberas utilizar el flag <em>--env</em>.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ php app/console assetic:dump --env=dev

$ php app/console assetic:dump --env=prod
</code></pre></div>
<p>Nosotros tenemos deshabilitado por defecto que Symfony realice esta tarea por nosotros. Esto agiliza la carga en el entorno de desarrollo. En todo caso, existe un comando <em>watch</em> que se encarga de observar si hemos realizado alguna modificación en nuestros assets, y es entonces cuando aplica el <em>assetic dump</em>.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">$ php app/console assetic:watch
</code></pre></div>
<hr>

<h2>Bundles externos</h2>

<p>Este workflow funciona bastante bien si la librería front-end requerida se adapta a la forma de trabaja de Symfony. En algunos casos es mejor optar por algún bundle externo. Por ejemplo <a href="https://github.com/egeloen/IvoryCKEditorBundle">IvoryCKEditorBundle</a> y <a href="https://github.com/marcaube/ObHighchartsBundle">ObHighchartsBundle</a> son dos bundles que nos simplifican la forma de trabajar con <a href="http://ckeditor.com/">CKEditor</a> y <a href="http://www.highcharts.com/">Highchart</a>.</p>

		</div>
	</div>
</div>

  </div>

  <!--Footer-->
  <div class="row">
    <hr>
    <footer>
      <div class="small-12 columns">
        <p>Blog desarrollado con <a href="http://jekyllrb.com">Jekyll</a> y <a href="http://foundation.zurb.com">Foundation</a>. Alojado en <a href="https://github.com/brunogarcia/brunogarcia.github.io">GitHub Pages</a>. Suscríbete al <a href="/feed.xml">RSS</a></p>
      </div>

    </footer>
  </div>

  <script src="/js/build/production.min.js"></script>
</body>
</html>
